{"version":3,"sources":["App.tsx","serviceWorker.ts","World.ts","Timer.ts","Random.ts","index.tsx","utilities.ts"],"names":["App","world","React","useState","getElements","elements","setElements","useEffect","onUpdate","removeCb","viewBox","preserveAspectRatio","xmlns","id","map","e","i","x","y","fontSize","size","transform","angle","key","Math","ceil","value","Boolean","window","location","hostname","match","World","timer","random","updateCbs","onTick","interval","update","cb","this","push","filter","cb1","timeScale","yVel","xVel","angleVel","valueVel","newElem","forEach","v","Timer","cbs","refresh","setTimeout","Random","seed","prng","seedrandom","min","max","quick","isTest","URLSearchParams","search","has","undefined","n","f","times","tick","start","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a74cbd62.chunk.js","sourcesContent":["import React, { useEffect } from 'react'\nimport './App.css';\nimport { World, Element } from './World';\n\ninterface AppProps {\n\n  readonly world: World;\n\n}\n\nconst App: React.FC<AppProps> = ({ world }) => {\n  \n  const [elements, setElements] = React.useState(world.getElements());\n\n  useEffect(() => {\n    world.onUpdate(setElements);\n\n    return () => {\n      world.removeCb(setElements);\n    };\n  }, [world]);\n\n  return (\n    <svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" xmlns=\"http://www.w3.org/2000/svg\" id='app'>\n      { elements.map((e: Element, i: number) =>\n        <text\n          x={e.x}\n          y={e.y}\n          fontSize={e.size}\n          transform={`rotate(${e.angle})`}\n          key={`el-${i}`}\n        >\n            {Math.ceil(e.value)}\n        </text>\n      )}\n    </svg>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { Timer } from \"./Timer\";\nimport { Random } from \"./Random\";\n\ntype OnElementsUpdate = (elements: Element[]) => void;\n\nexport interface Element {\n    x: number;\n    y: number;\n    xVel: number;\n    yVel: number;\n    angle: number;\n    angleVel: number;\n    value: number; /* 1 to 9 */\n    valueVel: number;\n    size: number;\n}\n\nconst yTotMax = 100;\nconst xTotMin = -10;\nconst xTotMax = 110;\n\nconst xMin = 0;\nconst xMax = 100;\n\nconst xVelMin = -6;\nconst xVelMax = 6;\n\nconst yVelMin = 8;\nconst yVelMax = 50;\n\nconst angleMin = -180;\nconst angleMax = 180;\n\nconst angleVelMin = -120;\nconst angleVelMax = 120;\n\nconst valueMin = 1;\nconst valueMax = 9;\n\nconst valueVelMin = 0.2;\nconst valueVelMax = 4;\n\nconst sizeMin = 6;\nconst sizeMax = 24;\n\nconst newElsPerSec = 2;\n\nexport class World {\n\n    private elements: Element[] = [];\n    private updateCbs: OnElementsUpdate[] = [];\n\n    constructor(timer: Timer, private readonly random: Random) {\n\n        timer.onTick((interval: number) => {\n            this.update(interval);\n        });\n    }\n\n    public onUpdate(cb: OnElementsUpdate) {\n        this.updateCbs.push(cb);\n    }\n    \n    public getElements(): Element[] {\n        return this.elements;\n    }\n\n    public removeCb(cb: OnElementsUpdate) {\n        this.updateCbs = this.updateCbs.filter(cb1 => cb1 !== cb);\n    }\n\n    private update(interval:number) {\n        this.elements = this.elements.map(e => \n            ({\n                ...e,\n                y: e.y + this.timeScale(e.yVel, interval),\n                x: e.x + this.timeScale(e.xVel, interval),\n                angle: e.angle + this.timeScale(e.angleVel, interval),\n                value: e.value - this.timeScale(e.valueVel, interval),\n            })).filter(e =>\n                 e.y < yTotMax + e.size &&\n                 e.x > xTotMin &&\n                 e.x < xTotMax &&\n                 e.value > 0\n            );\n        \n        if (this.random.random(0, 1) < this.timeScale(newElsPerSec, interval)) {\n            const newElem = {\n                x: this.random.random(xMin, xMax),\n                y: 0,\n                xVel: this.random.random(xVelMin, xVelMax),\n                yVel: this.random.random(yVelMin, yVelMax),\n                angle: this.random.random(angleMin, angleMax),\n                angleVel: this.random.random(angleVelMin, angleVelMax),\n                value: this.random.random(valueMin, valueMax),\n                valueVel: this.random.random(valueVelMin, valueVelMax),\n                size: this.random.random(sizeMin, sizeMax),\n            };\n            this.elements.push(newElem);\n        }\n        this.updateCbs.forEach(cb => cb(this.elements));\n    }\n\n    private timeScale(v: number, interval: number) {\n        return v / 1000 * interval;\n    }\n\n}","export type OnTickCallback = (interval: number) => void;\n\nexport const MS_INTERVAL = 15;\n\nexport class Timer {\n\n    private readonly cbs: OnTickCallback[] = [];\n\n    public start() {\n        this.refresh();\n    }\n\n    public onTick(cb: OnTickCallback): void {\n        this.cbs.push(cb);\n    }\n\n    public tick(interval: number = MS_INTERVAL): void {\n        this.cbs.forEach(cb => cb(interval));\n    } \n\n    private refresh(): void {\n        setTimeout(() => {\n            this.cbs.forEach(cb => cb(MS_INTERVAL));\n            this.refresh();\n        }, MS_INTERVAL);\n    }\n\n}","import seedrandom from 'seedrandom';\n\nexport class Random {\n\n    private prng: seedrandom.prng;\n\n    constructor(seed?: string) {\n        this.prng = seedrandom(seed);\n    }\n\n    public random(min: number, max: number): number {\n        return this.prng.quick() * (max - min) + min;\n    }\n\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { World } from './World';\nimport { Timer } from './Timer';\nimport { times } from './utilities';\nimport { Random } from './Random';\n\nconst params = new URLSearchParams(window.location.search);\nconst isTest = params.has('test');\nconst seed = isTest ? 'test' : undefined;\nconst initialRuns = 1500;\nconst timer = new Timer();\nconst random = new Random(seed);\nconst world = new World(timer, random);\ntimes(initialRuns, () => timer.tick());\n\nif (!isTest) {\n    timer.start();\n}\n\nReactDOM.render(<App world={world}/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const times = (n: number, f: () => void) => {\n    while(n-->0) {\n        f();\n    }\n};\n"],"sourceRoot":""}